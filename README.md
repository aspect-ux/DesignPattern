设计模式
一、类与类之间的关系：6个关系
 - 聚合关系，整体与部分的关系（空心菱形），整体与局部的关系可分离，如“学校和老师”
 - 组合关系， 一种更强的聚合关系，关键在于整体与局部无法分离，犹如“头和嘴巴”的关系（实心菱形）
 - 关联关系，持有另一个类的成员变量。  单向，双向，自关联（实线）
 - 依赖关系，耦合度弱的关联关系，通过“局部变量”调用另一个类的方法（虚线）
 - 继承关系（泛化）空心箭头实线指向父类，父类是子类的泛化
 - 实现关系,空心箭头+虚线指向接口

二、软件设计原则 ：6个原则
 - 开闭原则，对扩展开放，对修改关闭
 - 里氏替换原则，确定继承关系，子类拓展父类，保证子类不改变父类功能
 - 依赖倒转，高层模块不依赖低层，建立抽象类，高层调用抽象，低层实现（继承）抽象
 - 接口隔离原则，客户端不应该被迫依赖它不使用的方法，使用（依赖）的接口或类应当最小化
 - 迪米特法则，最少知识原则，如明星与粉丝之间的交接有一个经纪人，除了与朋友交流，陌生人应代理交接；
   如果两个软件实体无需直接通信，为了降低耦合度，可以通过新建第三方来调用转发
 - 合成复用原则，尽量先组合或聚合，然后再考虑继承，继承复用又叫做“白箱”复用，破坏了类的封装性，
   父类对子类来说是透明的；而组合或聚合复用，将类的对象纳入成员，维护类的封装性，对象耦合度低，复用灵活性高。

三、设计模式：23种设计模式
创建型结构型行为型
- 创建者模式
  1.单例设计模式
   - 饿汉式：提前声明static对象并初始化，需要直接返回
   - 懒汉式：需要时再new对象返回，线程安全版，双层判空包围同步；也可以final方式，这样保证线程安全。
   2./3.工厂模式
   - 简单工厂：违背开闭原则  也有叫做静态工厂的,用static修饰(不属于the 23）
   - 工厂方法：抽象工厂，抽象产品，具体工厂，具体产品
   - 抽象工厂：类似于工厂方法，但是增加了产品族这个概念，一个工厂不再只产出一种产品，而是同一产品族产品，
      这样也保证了扩展的合理性，不相关的产品不同工厂，不同但是同一体系或分类用同一个工厂。
      不用一股脑添加新的工厂。
      缺点是产品族增加新产品，需要修改所有工厂类，因为使用接口或abstract,需要重写。
      -番外：模式扩展，简单工厂+配置文件解除耦合
       4.原型模式
       有一个Cloneable接口或抽象类，实现/继承用于自我复制，避免繁琐的new
       对于基本数据类型，克隆复制正常，但是对于引用类型如String,由于浅克隆的效果，
       后续更改会把被克隆体的数据也修改；
       对于引用类型，需要重写Cloneable,不是自带的clone,通过序列化的方式来深克隆。
       对于String,由于String字符串池的存在，简单的=赋值只会是浅复制，因为一开始会再pool中查找到相同的string,
       就会让之指向同一块地址
       5.创建者模式
       抽象Builder写指令,具体Builder实现指令方法，Director符合迪米特法则，用来包含Builder对象和调用方法

-结构型模式

   6. 代理模式
      拿火车站来举例，火车站售票点聚合于代理售票点，合成复用原则，优先使用聚合/组合，而不是继承/实现
      7.适配器模式
      adaptee是被适配的组件接口
      target是需求接口，比如需要适配SD读取TF，那么调用SD接口就是目标
   - 类适配器模式

    adapter继承/实现 适配目标的实现，违背了合成服用原则，适用于客户端有接口规范
   - 对象适配模式

    改进了adapter适配器，不再继承/实现，而是聚合/组合
    适用于适配新旧、第三方的适配
8.装饰者模式：分为构件 、 装饰器的抽象与实现
具体来说，这个模式装饰器同时聚合和继承了抽象构件。
需要添加新功能的时候可以通过装饰器传送”老构件“，构建”新构件“
与代理模式的区别：装饰者为了增强对象，代理为了保护对象；装饰者外部传对象，代理内部创建对象
9.桥接
当扩展功能需要新增一个维度的类时
需要抽象化和实现化的角色
用接口包裹功能聚合与实现的基类   

10.外观模式（Facade）
    有外观角色和子系统角色，外观用于聚合所有子系统，调用子系统功能
    不符合开闭原则
    应用场景：复杂子系统很多，外观角色可以充当接口，提高子系统独立性和可移植性
   11.组合模式
    角色：抽象根节点，树枝节点，叶子节点，后两者继承于前者
    应用如文件菜单，关系如抽象根节点+文件夹+文件，文件/文件夹可以聚合于文件夹，所以用抽象根节点来泛化

    - 透明组合模式，根节点暴露所有crud方法，好用但不怎么安全
        - 安全组合模式，反之

12.享元模式（Flyweight)
 享元角色，非享元角色，享元工厂  
 享元工厂有单例字典，用于存储对象类型，简而言之就是储存可以公共访问的数据

 - 内部状态，不会随环境变化的可共享部分
 - 外部状态，随环境变化的不可共享部分
   -行为型模式

13.模板方法模式
 抽象类中给出算法模板或骨架
14.策略模式
 抽象策略（Strategy)，具体策略，环境(context)
 缺点，客户端需要知道所有策略类，可以通过享元模式适当减少
15.命令模式
 命令抽象具体类，实现者/接收者Receiver，调用者Invoker
 在餐厅的例子中，服务员聚合了一大堆命令是Invoker,厨师实现命令接口是Receiver,
优点：降低系统耦合度，增加删除很方便，符合开闭原则，可以配合组合模式，将多个命令组合成一个宏命令；undo redo
缺点：可能导致某些系统有过多的命令类，系统结构更加复杂
场景：调用者和接收者解耦，不同时间指定请求，排队请求和执行请求，undo redo
16.责任链模式
 Handler抽象与具体，拿公司请假多个领导批准举例，各个级别领导是handler的具体，客户端new对象
 handler中有submit 和 nextHandler,保证责任链能够不断提交下去
17.状态模式
 常规状态描述：将各种状态写入，大量switch，扩展性差
 状态模式：抽象和具体结构，环境三个角色
 设置状态基类，实现状态类，将环境context放入状态基类，拿电梯状态来说，”运行中的电梯“继承电梯状态，
 重写时可以结合环境上下文多样化地设置电梯权限。
 18.观察者模式（Publish/Subscribe模式)
 Observer和Subject,观察者和被观察对象，同时具有抽象和具体
observer具有update的能力，subject中有observer对象。可以增删，通知消息，subject执行操作后，
 可以手动提醒观察者
 优点，降低目标和观察者的耦合关系，所有的观察者都会受到消息
 优点：观察者多容易延迟接收，观察者有循环依赖会循环调用通知，导致系统崩溃
 19.中介者模式
 角色：中介者，同事
 拿租房举例，租房的人和房屋拥有者都有中介的信息，中介也与两者有联系，但是两者之间无关系
 松散耦合
 同事太多会导致中介者
 20.迭代器模式
 角色：聚合（aggregate)，迭代器(iterator)
 迭代器定义了对象的遍历迭代，聚合器则包含了对象的所有数据，以及对对象的增减迭代
 21.访问者模式
 抽象访问者->具体访问者；抽象被访问者->具体被访问者；访问结构角色

 - 静态分派 ：方法重载（编译时期）
 - 动态分派：动态置换到某个方法（运行时期）
 - 双分派：
   ....
   22.备忘录模式
   发起人（Originator)
   备忘率（Memento)
   管理者（Caretaker)
   ....
   23.解释器模式
